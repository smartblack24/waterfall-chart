import {
  Line
} from "./chunk-PUYLMVD7.js";
import {
  require_memoize
} from "./chunk-5MH7OQNH.js";
import "./chunk-YHCR3D3G.js";
import {
  Group,
  require_classnames
} from "./chunk-GIRWBFU4.js";
import {
  coerceNumber,
  getTicks,
  toString
} from "./chunk-ASNVMPOO.js";
import {
  require_prop_types
} from "./chunk-BEIIEGHX.js";
import {
  require_react
} from "./chunk-PGVW4JXJ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// ../../node_modules/.pnpm/balanced-match@0.4.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@0.4.2/node_modules/balanced-match/index.js"(exports, module) {
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match2 = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/reduce-function-call@1.0.3/node_modules/reduce-function-call/index.js
var require_reduce_function_call = __commonJS({
  "../../node_modules/.pnpm/reduce-function-call@1.0.3/node_modules/reduce-function-call/index.js"(exports, module) {
    var balanced = require_balanced_match2();
    module.exports = reduceFunctionCall;
    function reduceFunctionCall(string, functionRE, callback) {
      var call = string;
      return getFunctionCalls(string, functionRE).reduce(function(string2, obj) {
        return string2.replace(obj.functionIdentifier + "(" + obj.matches.body + ")", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE));
      }, string);
    }
    function getFunctionCalls(call, functionRE) {
      var expressions = [];
      var fnRE = typeof functionRE === "string" ? new RegExp("\\b(" + functionRE + ")\\(") : functionRE;
      do {
        var searchMatch = fnRE.exec(call);
        if (!searchMatch) {
          return expressions;
        }
        if (searchMatch[1] === void 0) {
          throw new Error("Missing the first couple of parenthesis to get the function identifier in " + functionRE);
        }
        var fn = searchMatch[1];
        var startIndex = searchMatch.index;
        var matches = balanced("(", ")", call.substring(startIndex));
        if (!matches || matches.start !== searchMatch[0].length - 1) {
          throw new SyntaxError(fn + "(): missing closing ')' in the value '" + call + "'");
        }
        expressions.push({ matches, functionIdentifier: fn });
        call = matches.post;
      } while (fnRE.test(call));
      return expressions;
    }
    function evalFunctionCall(string, functionIdentifier, callback, call, functionRE) {
      return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call);
    }
  }
});

// ../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/math_function.js
var require_math_function = __commonJS({
  "../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/math_function.js"(exports, module) {
    "use strict";
    var Mexp = function(parsed) {
      this.value = parsed;
    };
    Mexp.math = {
      isDegree: true,
      // mode of calculator
      acos: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.acos(x) : Math.acos(x);
      },
      add: function(a, b) {
        return a + b;
      },
      asin: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.asin(x) : Math.asin(x);
      },
      atan: function(x) {
        return Mexp.math.isDegree ? 180 / Math.PI * Math.atan(x) : Math.atan(x);
      },
      acosh: function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      },
      asinh: function(x) {
        return Math.log(x + Math.sqrt(x * x + 1));
      },
      atanh: function(x) {
        return Math.log((1 + x) / (1 - x));
      },
      C: function(n, r) {
        var pro = 1;
        var other = n - r;
        var choice = r;
        if (choice < other) {
          choice = other;
          other = r;
        }
        for (var i = choice + 1; i <= n; i++) {
          pro *= i;
        }
        return pro / Mexp.math.fact(other);
      },
      changeSign: function(x) {
        return -x;
      },
      cos: function(x) {
        if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
        return Math.cos(x);
      },
      cosh: function(x) {
        return (Math.pow(Math.E, x) + Math.pow(Math.E, -1 * x)) / 2;
      },
      div: function(a, b) {
        return a / b;
      },
      fact: function(n) {
        if (n % 1 !== 0) return "NaN";
        var pro = 1;
        for (var i = 2; i <= n; i++) {
          pro *= i;
        }
        return pro;
      },
      inverse: function(x) {
        return 1 / x;
      },
      log: function(i) {
        return Math.log(i) / Math.log(10);
      },
      mod: function(a, b) {
        return a % b;
      },
      mul: function(a, b) {
        return a * b;
      },
      P: function(n, r) {
        var pro = 1;
        for (var i = Math.floor(n) - Math.floor(r) + 1; i <= Math.floor(n); i++) {
          pro *= i;
        }
        return pro;
      },
      Pi: function(low, high, ex) {
        var pro = 1;
        for (var i = low; i <= high; i++) {
          pro *= Number(ex.postfixEval({
            n: i
          }));
        }
        return pro;
      },
      pow10x: function(e) {
        var x = 1;
        while (e--) {
          x *= 10;
        }
        return x;
      },
      sigma: function(low, high, ex) {
        var sum = 0;
        for (var i = low; i <= high; i++) {
          sum += Number(ex.postfixEval({
            n: i
          }));
        }
        return sum;
      },
      sin: function(x) {
        if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
        return Math.sin(x);
      },
      sinh: function(x) {
        return (Math.pow(Math.E, x) - Math.pow(Math.E, -1 * x)) / 2;
      },
      sub: function(a, b) {
        return a - b;
      },
      tan: function(x) {
        if (Mexp.math.isDegree) x = Mexp.math.toRadian(x);
        return Math.tan(x);
      },
      tanh: function(x) {
        return Mexp.sinha(x) / Mexp.cosha(x);
      },
      toRadian: function(x) {
        return x * Math.PI / 180;
      },
      and: function(a, b) {
        return a & b;
      }
    };
    Mexp.Exception = function(message) {
      this.message = message;
    };
    module.exports = Mexp;
  }
});

// ../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/lexer.js"(exports, module) {
    "use strict";
    var Mexp = require_math_function();
    function inc(arr, val) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        arr[i2] += val;
      }
      return arr;
    }
    var tokens = [
      { token: "sin", show: "sin", type: 0, value: Mexp.math.sin },
      { token: "cos", show: "cos", type: 0, value: Mexp.math.cos },
      { token: "tan", show: "tan", type: 0, value: Mexp.math.tan },
      { token: "pi", show: "&pi;", type: 3, value: "PI" },
      { token: "(", show: "(", type: 4, value: "(" },
      { token: ")", show: ")", type: 5, value: ")" },
      { token: "P", show: "P", type: 10, value: Mexp.math.P },
      { token: "C", show: "C", type: 10, value: Mexp.math.C },
      { token: " ", show: " ", type: 14, value: " ".anchor },
      { token: "asin", show: "asin", type: 0, value: Mexp.math.asin },
      { token: "acos", show: "acos", type: 0, value: Mexp.math.acos },
      { token: "atan", show: "atan", type: 0, value: Mexp.math.atan },
      { token: "7", show: "7", type: 1, value: "7" },
      { token: "8", show: "8", type: 1, value: "8" },
      { token: "9", show: "9", type: 1, value: "9" },
      { token: "int", show: "Int", type: 0, value: Math.floor },
      { token: "cosh", show: "cosh", type: 0, value: Mexp.math.cosh },
      { token: "acosh", show: "acosh", type: 0, value: Mexp.math.acosh },
      { token: "ln", show: " ln", type: 0, value: Math.log },
      { token: "^", show: "^", type: 10, value: Math.pow },
      { token: "root", show: "root", type: 0, value: Math.sqrt },
      { token: "4", show: "4", type: 1, value: "4" },
      { token: "5", show: "5", type: 1, value: "5" },
      { token: "6", show: "6", type: 1, value: "6" },
      { token: "/", show: "&divide;", type: 2, value: Mexp.math.div },
      { token: "!", show: "!", type: 7, value: Mexp.math.fact },
      { token: "tanh", show: "tanh", type: 0, value: Mexp.math.tanh },
      { token: "atanh", show: "atanh", type: 0, value: Mexp.math.atanh },
      { token: "Mod", show: " Mod ", type: 2, value: Mexp.math.mod },
      { token: "1", show: "1", type: 1, value: "1" },
      { token: "2", show: "2", type: 1, value: "2" },
      { token: "3", show: "3", type: 1, value: "3" },
      { token: "*", show: "&times;", type: 2, value: Mexp.math.mul },
      { token: "sinh", show: "sinh", type: 0, value: Mexp.math.sinh },
      { token: "asinh", show: "asinh", type: 0, value: Mexp.math.asinh },
      { token: "e", show: "e", type: 3, value: "E" },
      { token: "log", show: " log", type: 0, value: Mexp.math.log },
      { token: "0", show: "0", type: 1, value: "0" },
      { token: ".", show: ".", type: 6, value: "." },
      { token: "+", show: "+", type: 9, value: Mexp.math.add },
      { token: "-", show: "-", type: 9, value: Mexp.math.sub },
      { token: ",", show: ",", type: 11, value: "," },
      { token: "Sigma", show: "&Sigma;", type: 12, value: Mexp.math.sigma },
      { token: "n", show: "n", type: 13, value: "n" },
      { token: "Pi", show: "&Pi;", type: 12, value: Mexp.math.Pi },
      { token: "pow", show: "pow", type: 8, value: Math.pow, numberOfArguments: 2 },
      { token: "&", show: "&", type: 9, value: Mexp.math.and }
    ];
    var preced = {
      0: 11,
      1: 0,
      2: 3,
      3: 0,
      4: 0,
      5: 0,
      6: 0,
      7: 11,
      8: 11,
      9: 1,
      10: 10,
      11: 0,
      12: 11,
      13: 0,
      14: -1,
      15: 11
      // will be filtered after lexer
    };
    for (i = 0; i < tokens.length; i++) {
      tokens[i].precedence = preced[tokens[i].type];
    }
    var i;
    var type0 = {
      0: true,
      1: true,
      3: true,
      4: true,
      6: true,
      8: true,
      9: true,
      12: true,
      13: true,
      14: true,
      15: true
    };
    var type1 = {
      0: true,
      1: true,
      2: true,
      3: true,
      4: true,
      5: true,
      6: true,
      7: true,
      8: true,
      9: true,
      10: true,
      11: true,
      12: true,
      13: true,
      15: true
    };
    var type1Asterick = {
      0: true,
      3: true,
      4: true,
      8: true,
      12: true,
      13: true,
      15: true
    };
    var empty = {};
    var type3Asterick = {
      0: true,
      1: true,
      3: true,
      4: true,
      6: true,
      8: true,
      12: true,
      13: true,
      15: true
    };
    var type6 = {
      1: true
    };
    var newAr = [
      [],
      [
        "1",
        "2",
        "3",
        "7",
        "8",
        "9",
        "4",
        "5",
        "6",
        "+",
        "-",
        "*",
        "/",
        "(",
        ")",
        "^",
        "!",
        "P",
        "C",
        "e",
        "0",
        ".",
        ",",
        "n",
        " ",
        "&"
      ],
      ["pi", "ln", "Pi"],
      ["sin", "cos", "tan", "Del", "int", "Mod", "log", "pow"],
      ["asin", "acos", "atan", "cosh", "root", "tanh", "sinh"],
      ["acosh", "atanh", "asinh", "Sigma"]
    ];
    function match(str1, str2, i2, x) {
      for (var f = 0; f < x; f++) {
        if (str1[i2 + f] !== str2[f]) {
          return false;
        }
      }
      return true;
    }
    Mexp.tokenTypes = {
      FUNCTION_WITH_ONE_ARG: 0,
      NUMBER: 1,
      BINARY_OPERATOR_HIGH_PRECENDENCE: 2,
      CONSTANT: 3,
      OPENING_PARENTHESIS: 4,
      CLOSING_PARENTHESIS: 5,
      DECIMAL: 6,
      POSTFIX_FUNCTION_WITH_ONE_ARG: 7,
      FUNCTION_WITH_N_ARGS: 8,
      BINARY_OPERATOR_LOW_PRECENDENCE: 9,
      BINARY_OPERATOR_PERMUTATION: 10,
      COMMA: 11,
      EVALUATED_FUNCTION: 12,
      EVALUATED_FUNCTION_PARAMETER: 13,
      SPACE: 14
    };
    Mexp.addToken = function(newTokens) {
      for (var i2 = 0; i2 < newTokens.length; i2++) {
        var x = newTokens[i2].token.length;
        var temp = -1;
        if (newTokens[i2].type === Mexp.tokenTypes.FUNCTION_WITH_N_ARGS && newTokens[i2].numberOfArguments === void 0) {
          newTokens[i2].numberOfArguments = 2;
        }
        newAr[x] = newAr[x] || [];
        for (var y = 0; y < newAr[x].length; y++) {
          if (newTokens[i2].token === newAr[x][y]) {
            temp = indexOfToken(newAr[x][y], tokens);
            break;
          }
        }
        if (temp === -1) {
          tokens.push(newTokens[i2]);
          newTokens[i2].precedence = preced[newTokens[i2].type];
          if (newAr.length <= newTokens[i2].token.length) {
            newAr[newTokens[i2].token.length] = [];
          }
          newAr[newTokens[i2].token.length].push(newTokens[i2].token);
        } else {
          tokens[temp] = newTokens[i2];
          newTokens[i2].precedence = preced[newTokens[i2].type];
        }
      }
    };
    function indexOfToken(key, tokens2) {
      for (var search = 0; search < tokens2.length; search++) {
        if (tokens2[search].token === key) return search;
      }
      return -1;
    }
    function tokenize(string) {
      var nodes = [];
      var length = string.length;
      var key, x, y;
      for (var i2 = 0; i2 < length; i2++) {
        if (i2 < length - 1 && string[i2] === " " && string[i2 + 1] === " ") {
          continue;
        }
        key = "";
        for (x = string.length - i2 > newAr.length - 2 ? newAr.length - 1 : string.length - i2; x > 0; x--) {
          if (newAr[x] === void 0) continue;
          for (y = 0; y < newAr[x].length; y++) {
            if (match(string, newAr[x][y], i2, x)) {
              key = newAr[x][y];
              y = newAr[x].length;
              x = 0;
            }
          }
        }
        i2 += key.length - 1;
        if (key === "") {
          throw new Mexp.Exception("Can't understand after " + string.slice(i2));
        }
        nodes.push(tokens[indexOfToken(key, tokens)]);
      }
      return nodes;
    }
    var changeSignObj = {
      value: Mexp.math.changeSign,
      type: 0,
      pre: 21,
      show: "-"
    };
    var closingParObj = {
      value: ")",
      show: ")",
      type: 5,
      pre: 0
    };
    var openingParObj = {
      value: "(",
      type: 4,
      pre: 0,
      show: "("
    };
    Mexp.lex = function(inp, tokens2) {
      "use strict";
      var str = [openingParObj];
      var ptc = [];
      var inpStr = inp;
      var allowed = type0;
      var bracToClose = 0;
      var asterick = empty;
      var prevKey = "";
      var i2;
      if (typeof tokens2 !== "undefined") {
        Mexp.addToken(tokens2);
      }
      var obj = {};
      var nodes = tokenize(inpStr);
      for (i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.type === 14) {
          if (i2 > 0 && i2 < nodes.length - 1 && nodes[i2 + 1].type === 1 && (nodes[i2 - 1].type === 1 || nodes[i2 - 1].type === 6)) {
            throw new Mexp.Exception("Unexpected Space");
          }
          continue;
        }
        var cToken = node.token;
        var cType = node.type;
        var cEv = node.value;
        var cPre = node.precedence;
        var cShow = node.show;
        var pre = str[str.length - 1];
        var j;
        for (j = ptc.length; j--; ) {
          if (ptc[j] === 0) {
            if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {
              if (allowed[cType] !== true) {
                throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
              }
              str.push(closingParObj);
              allowed = type1;
              asterick = type3Asterick;
              ptc.pop();
            }
          } else break;
        }
        if (allowed[cType] !== true) {
          throw new Mexp.Exception(cToken + " is not allowed after " + prevKey);
        }
        if (asterick[cType] === true) {
          cType = 2;
          cEv = Mexp.math.mul;
          cShow = "&times;";
          cPre = 3;
          i2 = i2 - 1;
        }
        obj = {
          value: cEv,
          type: cType,
          pre: cPre,
          show: cShow,
          numberOfArguments: node.numberOfArguments
        };
        if (cType === 0) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(2);
          }
        } else if (cType === 1) {
          if (pre.type === 1) {
            pre.value += cEv;
            inc(ptc, 1);
          } else {
            str.push(obj);
          }
          allowed = type1;
          asterick = type1Asterick;
        } else if (cType === 2) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
        } else if (cType === 3) {
          str.push(obj);
          allowed = type1;
          asterick = type3Asterick;
        } else if (cType === 4) {
          inc(ptc, 1);
          bracToClose++;
          allowed = type0;
          asterick = empty;
          str.push(obj);
        } else if (cType === 5) {
          if (!bracToClose) {
            throw new Mexp.Exception("Closing parenthesis are more than opening one, wait What!!!");
          }
          bracToClose--;
          allowed = type1;
          asterick = type3Asterick;
          str.push(obj);
          inc(ptc, 1);
        } else if (cType === 6) {
          if (pre.hasDec) {
            throw new Mexp.Exception("Two decimals are not allowed in one number");
          }
          if (pre.type !== 1) {
            pre = {
              value: 0,
              type: 1,
              pre: 0
            };
            str.push(pre);
          }
          allowed = type6;
          inc(ptc, 1);
          asterick = empty;
          pre.value += cEv;
          pre.hasDec = true;
        } else if (cType === 7) {
          allowed = type1;
          asterick = type3Asterick;
          inc(ptc, 1);
          str.push(obj);
        }
        if (cType === 8) {
          allowed = type0;
          asterick = empty;
          inc(ptc, node.numberOfArguments + 2);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(node.numberOfArguments + 2);
          }
        } else if (cType === 9) {
          if (pre.type === 9) {
            if (pre.value === Mexp.math.add) {
              pre.value = cEv;
              pre.show = cShow;
              inc(ptc, 1);
            } else if (pre.value === Mexp.math.sub && cShow === "-") {
              pre.value = Mexp.math.add;
              pre.show = "+";
              inc(ptc, 1);
            }
          } else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) {
            if (cToken === "-") {
              allowed = type0;
              asterick = empty;
              inc(ptc, 2).push(2);
              str.push(changeSignObj);
              str.push(openingParObj);
            }
          } else {
            str.push(obj);
            inc(ptc, 2);
          }
          allowed = type0;
          asterick = empty;
        } else if (cType === 10) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 2);
          str.push(obj);
        } else if (cType === 11) {
          allowed = type0;
          asterick = empty;
          str.push(obj);
        } else if (cType === 12) {
          allowed = type0;
          asterick = empty;
          inc(ptc, 6);
          str.push(obj);
          if (nodes[i2 + 1].type !== 4) {
            str.push(openingParObj);
            ptc.push(6);
          }
        } else if (cType === 13) {
          allowed = type1;
          asterick = type3Asterick;
          str.push(obj);
        }
        inc(ptc, -1);
        prevKey = cToken;
      }
      for (j = ptc.length; j--; ) {
        str.push(closingParObj);
      }
      if (allowed[5] !== true) {
        throw new Mexp.Exception("complete the expression");
      }
      while (bracToClose--) {
        str.push(closingParObj);
      }
      str.push(closingParObj);
      return new Mexp(str);
    };
    module.exports = Mexp;
  }
});

// ../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/postfix.js
var require_postfix = __commonJS({
  "../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/postfix.js"(exports, module) {
    var Mexp = require_lexer();
    Mexp.prototype.toPostfix = function() {
      "use strict";
      var post = [], elem, popped, prep, pre, ele;
      var stack = [{ value: "(", type: 4, pre: 0 }];
      var arr = this.value;
      for (var i = 1; i < arr.length; i++) {
        if (arr[i].type === 1 || arr[i].type === 3 || arr[i].type === 13) {
          if (arr[i].type === 1)
            arr[i].value = Number(arr[i].value);
          post.push(arr[i]);
        } else if (arr[i].type === 4) {
          stack.push(arr[i]);
        } else if (arr[i].type === 5) {
          while ((popped = stack.pop()).type !== 4) {
            post.push(popped);
          }
        } else if (arr[i].type === 11) {
          while ((popped = stack.pop()).type !== 4) {
            post.push(popped);
          }
          stack.push(popped);
        } else {
          elem = arr[i];
          pre = elem.pre;
          ele = stack[stack.length - 1];
          prep = ele.pre;
          var flag = ele.value == "Math.pow" && elem.value == "Math.pow";
          if (pre > prep) stack.push(elem);
          else {
            while (prep >= pre && !flag || flag && pre < prep) {
              popped = stack.pop();
              ele = stack[stack.length - 1];
              post.push(popped);
              prep = ele.pre;
              flag = elem.value == "Math.pow" && ele.value == "Math.pow";
            }
            stack.push(elem);
          }
        }
      }
      return new Mexp(post);
    };
    module.exports = Mexp;
  }
});

// ../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/postfix_evaluator.js
var require_postfix_evaluator = __commonJS({
  "../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/postfix_evaluator.js"(exports, module) {
    var Mexp = require_postfix();
    Mexp.prototype.postfixEval = function(UserDefined) {
      "use strict";
      UserDefined = UserDefined || {};
      UserDefined.PI = Math.PI;
      UserDefined.E = Math.E;
      var stack = [], pop1, pop2, pop3;
      var disp = [];
      var temp = "";
      var arr = this.value;
      var bool = typeof UserDefined.n !== "undefined";
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].type === 1) {
          stack.push({ value: arr[i].value, type: 1 });
        } else if (arr[i].type === 3) {
          stack.push({ value: UserDefined[arr[i].value], type: 1 });
        } else if (arr[i].type === 0) {
          if (typeof stack[stack.length - 1].type === "undefined") {
            stack[stack.length - 1].value.push(arr[i]);
          } else stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
        } else if (arr[i].type === 7) {
          if (typeof stack[stack.length - 1].type === "undefined") {
            stack[stack.length - 1].value.push(arr[i]);
          } else stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value);
        } else if (arr[i].type === 8) {
          var popped = [];
          for (var x = 0; x < arr[i].numberOfArguments; x++) {
            popped.push(stack.pop().value);
          }
          stack.push({ type: 1, value: arr[i].value.apply(arr[i], popped.reverse()) });
        } else if (arr[i].type === 10) {
          pop1 = stack.pop();
          pop2 = stack.pop();
          if (typeof pop2.type === "undefined") {
            pop2.value = pop2.concat(pop1);
            pop2.value.push(arr[i]);
            stack.push(pop2);
          } else if (typeof pop1.type === "undefined") {
            pop1.unshift(pop2);
            pop1.push(arr[i]);
            stack.push(pop1);
          } else {
            stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
          }
        } else if (arr[i].type === 2 || arr[i].type === 9) {
          pop1 = stack.pop();
          pop2 = stack.pop();
          if (typeof pop2.type === "undefined") {
            pop2 = pop2.concat(pop1);
            pop2.push(arr[i]);
            stack.push(pop2);
          } else if (typeof pop1.type === "undefined") {
            pop1.unshift(pop2);
            pop1.push(arr[i]);
            stack.push(pop1);
          } else {
            stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) });
          }
        } else if (arr[i].type === 12) {
          pop1 = stack.pop();
          if (typeof pop1.type !== "undefined") {
            pop1 = [pop1];
          }
          pop2 = stack.pop();
          pop3 = stack.pop();
          stack.push({ type: 1, value: arr[i].value(pop3.value, pop2.value, new Mexp(pop1)) });
        } else if (arr[i].type === 13) {
          if (bool) {
            stack.push({ value: UserDefined[arr[i].value], type: 3 });
          } else stack.push([arr[i]]);
        }
      }
      if (stack.length > 1) {
        throw new Mexp.Exception("Uncaught Syntax error");
      }
      return stack[0].value > 1e15 ? "Infinity" : parseFloat(stack[0].value.toFixed(15));
    };
    Mexp.eval = function(str, tokens, obj) {
      if (typeof tokens === "undefined") {
        return this.lex(str).toPostfix().postfixEval();
      } else if (typeof obj === "undefined") {
        if (typeof tokens.length !== "undefined") return this.lex(str, tokens).toPostfix().postfixEval();
        else return this.lex(str).toPostfix().postfixEval(tokens);
      } else return this.lex(str, tokens).toPostfix().postfixEval(obj);
    };
    module.exports = Mexp;
  }
});

// ../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/formula_evaluator.js
var require_formula_evaluator = __commonJS({
  "../../node_modules/.pnpm/math-expression-evaluator@1.4.0/node_modules/math-expression-evaluator/src/formula_evaluator.js"(exports, module) {
    var Mexp = require_postfix_evaluator();
    Mexp.prototype.formulaEval = function() {
      "use strict";
      var stack = [], pop1, pop2, pop3;
      var disp = [];
      var temp = "";
      var arr = this.value;
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].type === 1 || arr[i].type === 3) {
          disp.push({ value: arr[i].type === 3 ? arr[i].show : arr[i].value, type: 1 });
        } else if (arr[i].type === 13) {
          disp.push({ value: arr[i].show, type: 1 });
        } else if (arr[i].type === 0) {
          disp[disp.length - 1] = { value: arr[i].show + (arr[i].show != "-" ? "(" : "") + disp[disp.length - 1].value + (arr[i].show != "-" ? ")" : ""), type: 0 };
        } else if (arr[i].type === 7) {
          disp[disp.length - 1] = { value: (disp[disp.length - 1].type != 1 ? "(" : "") + disp[disp.length - 1].value + (disp[disp.length - 1].type != 1 ? ")" : "") + arr[i].show, type: 7 };
        } else if (arr[i].type === 10) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          if (arr[i].show === "P" || arr[i].show === "C") disp.push({ value: "<sup>" + pop2.value + "</sup>" + arr[i].show + "<sub>" + pop1.value + "</sub>", type: 10 });
          else disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + "<sup>" + pop1.value + "</sup>", type: 1 });
        } else if (arr[i].type === 2 || arr[i].type === 9) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          disp.push({ value: (pop2.type != 1 ? "(" : "") + pop2.value + (pop2.type != 1 ? ")" : "") + arr[i].show + (pop1.type != 1 ? "(" : "") + pop1.value + (pop1.type != 1 ? ")" : ""), type: arr[i].type });
        } else if (arr[i].type === 12) {
          pop1 = disp.pop();
          pop2 = disp.pop();
          pop3 = disp.pop();
          disp.push({ value: arr[i].show + "(" + pop3.value + "," + pop2.value + "," + pop1.value + ")", type: 12 });
        }
      }
      return disp[0].value;
    };
    module.exports = Mexp;
  }
});

// ../../node_modules/.pnpm/reduce-css-calc@1.3.0/node_modules/reduce-css-calc/index.js
var require_reduce_css_calc = __commonJS({
  "../../node_modules/.pnpm/reduce-css-calc@1.3.0/node_modules/reduce-css-calc/index.js"(exports, module) {
    var balanced = require_balanced_match();
    var reduceFunctionCall = require_reduce_function_call();
    var mexp = require_formula_evaluator();
    var MAX_STACK = 100;
    var NESTED_CALC_RE = /(\+|\-|\*|\\|[^a-z]|)(\s*)(\()/g;
    var stack;
    module.exports = reduceCSSCalc2;
    function reduceCSSCalc2(value, decimalPrecision) {
      stack = 0;
      decimalPrecision = Math.pow(10, decimalPrecision === void 0 ? 5 : decimalPrecision);
      value = value.replace(/\n+/g, " ");
      function evaluateExpression(expression, functionIdentifier, call) {
        if (stack++ > MAX_STACK) {
          stack = 0;
          throw new Error("Call stack overflow for " + call);
        }
        if (expression === "") {
          throw new Error(functionIdentifier + "(): '" + call + "' must contain a non-whitespace string");
        }
        expression = evaluateNestedExpression(expression, call);
        var units = getUnitsInExpression(expression);
        if (units.length > 1 || expression.indexOf("var(") > -1) {
          return functionIdentifier + "(" + expression + ")";
        }
        var unit = units[0] || "";
        if (unit === "%") {
          expression = expression.replace(/\b[0-9\.]+%/g, function(percent) {
            return parseFloat(percent.slice(0, -1)) * 0.01;
          });
        }
        var toEvaluate = expression.replace(new RegExp(unit, "gi"), "");
        var result;
        try {
          result = mexp.eval(toEvaluate);
        } catch (e) {
          return functionIdentifier + "(" + expression + ")";
        }
        if (unit === "%") {
          result *= 100;
        }
        if (functionIdentifier.length || unit === "%") {
          result = Math.round(result * decimalPrecision) / decimalPrecision;
        }
        result += unit;
        return result;
      }
      function evaluateNestedExpression(expression, call) {
        expression = expression.replace(/((?:\-[a-z]+\-)?calc)/g, "");
        var evaluatedPart = "";
        var nonEvaluatedPart = expression;
        var matches;
        while (matches = NESTED_CALC_RE.exec(nonEvaluatedPart)) {
          if (matches[0].index > 0) {
            evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index);
          }
          var balancedExpr = balanced("(", ")", nonEvaluatedPart.substring([0].index));
          if (balancedExpr.body === "") {
            throw new Error("'" + expression + "' must contain a non-whitespace string");
          }
          var evaluated = evaluateExpression(balancedExpr.body, "", call);
          evaluatedPart += balancedExpr.pre + evaluated;
          nonEvaluatedPart = balancedExpr.post;
        }
        return evaluatedPart + nonEvaluatedPart;
      }
      return reduceFunctionCall(value, /((?:\-[a-z]+\-)?calc)\(/, evaluateExpression);
    }
    function getUnitsInExpression(expression) {
      var uniqueUnits = [];
      var uniqueLowerCaseUnits = [];
      var unitRegEx = /[\.0-9]([%a-z]+)/gi;
      var matches = unitRegEx.exec(expression);
      while (matches) {
        if (!matches || !matches[1]) {
          continue;
        }
        if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {
          uniqueUnits.push(matches[1]);
          uniqueLowerCaseUnits.push(matches[1].toLowerCase());
        }
        matches = unitRegEx.exec(expression);
      }
      return uniqueUnits;
    }
  }
});

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/Axis.js
var import_prop_types = __toESM(require_prop_types());
var import_react5 = __toESM(require_react());
var import_classnames3 = __toESM(require_classnames());

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisRenderer.js
var import_react4 = __toESM(require_react());
var import_classnames2 = __toESM(require_classnames());

// ../../node_modules/.pnpm/@visx+text@3.12.0_react@18.3.1/node_modules/@visx/text/esm/Text.js
var import_react2 = __toESM(require_react());

// ../../node_modules/.pnpm/@visx+text@3.12.0_react@18.3.1/node_modules/@visx/text/esm/hooks/useText.js
var import_react = __toESM(require_react());
var import_reduce_css_calc = __toESM(require_reduce_css_calc());

// ../../node_modules/.pnpm/@visx+text@3.12.0_react@18.3.1/node_modules/@visx/text/esm/util/getStringWidth.js
var import_memoize = __toESM(require_memoize());
var MEASUREMENT_ELEMENT_ID = "__react_svg_text_measurement_id";
function getStringWidth(str, style) {
  try {
    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);
    if (!textEl) {
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("aria-hidden", "true");
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.position = "absolute";
      svg.style.top = "-100%";
      svg.style.left = "-100%";
      textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.setAttribute("id", MEASUREMENT_ELEMENT_ID);
      svg.appendChild(textEl);
      document.body.appendChild(svg);
    }
    Object.assign(textEl.style, style);
    textEl.textContent = str;
    return textEl.getComputedTextLength();
  } catch (e) {
    return null;
  }
}
var getStringWidth_default = (0, import_memoize.default)(getStringWidth, function(str, style) {
  return str + "_" + JSON.stringify(style);
});

// ../../node_modules/.pnpm/@visx+text@3.12.0_react@18.3.1/node_modules/@visx/text/esm/hooks/useText.js
var _excluded = ["verticalAnchor", "scaleToFit", "angle", "width", "lineHeight", "capHeight", "children", "style"];
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isNumber(val) {
  return typeof val === "number";
}
function isXOrYInValid(xOrY) {
  return (
    // number that is not NaN or Infinity
    typeof xOrY === "number" && Number.isFinite(xOrY) || // for percentage
    typeof xOrY === "string"
  );
}
function useText(props) {
  var _props$verticalAnchor = props.verticalAnchor, verticalAnchor = _props$verticalAnchor === void 0 ? "end" : _props$verticalAnchor, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, angle = props.angle, width = props.width, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$capHeight = props.capHeight, capHeight = _props$capHeight === void 0 ? "0.71em" : _props$capHeight, children = props.children, style = props.style, textProps = _objectWithoutPropertiesLoose(props, _excluded);
  var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, _textProps$y = textProps.y, y = _textProps$y === void 0 ? 0 : _textProps$y;
  var isXOrYNotValid = !isXOrYInValid(x) || !isXOrYInValid(y);
  var _useMemo = (0, import_react.useMemo)(function() {
    var words = children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/);
    return {
      wordsWithWidth: words.map(function(word) {
        return {
          word,
          wordWidth: getStringWidth_default(word, style) || 0
        };
      }),
      spaceWidth: getStringWidth_default(" ", style) || 0
    };
  }, [children, style]), wordsWithWidth = _useMemo.wordsWithWidth, spaceWidth = _useMemo.spaceWidth;
  var wordsByLines = (0, import_react.useMemo)(function() {
    if (isXOrYNotValid) {
      return [];
    }
    if (width || scaleToFit) {
      return wordsWithWidth.reduce(function(result, _ref) {
        var word = _ref.word, wordWidth = _ref.wordWidth;
        var currentLine = result[result.length - 1];
        if (currentLine && (width == null || scaleToFit || (currentLine.width || 0) + wordWidth + spaceWidth < width)) {
          currentLine.words.push(word);
          currentLine.width = currentLine.width || 0;
          currentLine.width += wordWidth + spaceWidth;
        } else {
          var newLine = {
            words: [word],
            width: wordWidth
          };
          result.push(newLine);
        }
        return result;
      }, []);
    }
    return [{
      words: children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/)
    }];
  }, [isXOrYNotValid, width, scaleToFit, children, wordsWithWidth, spaceWidth]);
  var startDy = (0, import_react.useMemo)(function() {
    var startDyStr = isXOrYNotValid ? "" : verticalAnchor === "start" ? (0, import_reduce_css_calc.default)("calc(" + capHeight + ")") : verticalAnchor === "middle" ? (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))") : (0, import_reduce_css_calc.default)("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
    return startDyStr;
  }, [isXOrYNotValid, verticalAnchor, capHeight, wordsByLines.length, lineHeight]);
  var transform = (0, import_react.useMemo)(function() {
    var transforms = [];
    if (isXOrYNotValid) {
      return "";
    }
    if (isNumber(x) && isNumber(y) && isNumber(width) && scaleToFit && wordsByLines.length > 0) {
      var lineWidth = wordsByLines[0].width || 1;
      var sx = scaleToFit === "shrink-only" ? Math.min(width / lineWidth, 1) : width / lineWidth;
      var sy = sx;
      var originX = x - sx * x;
      var originY = y - sy * y;
      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
    }
    if (angle) {
      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
    }
    return transforms.length > 0 ? transforms.join(" ") : "";
  }, [isXOrYNotValid, x, y, width, scaleToFit, wordsByLines, angle]);
  return {
    wordsByLines,
    startDy,
    transform
  };
}

// ../../node_modules/.pnpm/@visx+text@3.12.0_react@18.3.1/node_modules/@visx/text/esm/Text.js
var _excluded2 = ["dx", "dy", "textAnchor", "innerRef", "innerTextRef", "verticalAnchor", "angle", "lineHeight", "scaleToFit", "capHeight", "width"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var SVG_STYLE = {
  overflow: "visible"
};
function Text(props) {
  var _props$dx = props.dx, dx = _props$dx === void 0 ? 0 : _props$dx, _props$dy = props.dy, dy = _props$dy === void 0 ? 0 : _props$dy, _props$textAnchor = props.textAnchor, textAnchor = _props$textAnchor === void 0 ? "start" : _props$textAnchor, innerRef = props.innerRef, innerTextRef = props.innerTextRef, verticalAnchor = props.verticalAnchor, angle = props.angle, _props$lineHeight = props.lineHeight, lineHeight = _props$lineHeight === void 0 ? "1em" : _props$lineHeight, _props$scaleToFit = props.scaleToFit, scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit, capHeight = props.capHeight, width = props.width, textProps = _objectWithoutPropertiesLoose2(props, _excluded2);
  var _textProps$x = textProps.x, x = _textProps$x === void 0 ? 0 : _textProps$x, fontSize = textProps.fontSize;
  var _useText = useText(props), wordsByLines = _useText.wordsByLines, startDy = _useText.startDy, transform = _useText.transform;
  return import_react2.default.createElement("svg", {
    ref: innerRef,
    x: dx,
    y: dy,
    fontSize,
    style: SVG_STYLE
  }, wordsByLines.length > 0 ? import_react2.default.createElement("text", _extends({
    ref: innerTextRef,
    transform
  }, textProps, {
    textAnchor
  }), wordsByLines.map(function(line, index) {
    return import_react2.default.createElement("tspan", {
      key: index,
      x,
      dy: index === 0 ? startDy : lineHeight
    }, line.words.join(" "));
  })) : null);
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/constants/orientation.js
var Orientation = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
var orientation_default = Orientation;

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/utils/getLabelTransform.js
function getLabelTransform(_ref) {
  var labelOffset = _ref.labelOffset, labelProps = _ref.labelProps, orientation = _ref.orientation, range = _ref.range, tickLabelFontSize = _ref.tickLabelFontSize, tickLength = _ref.tickLength;
  var sign = orientation === orientation_default.left || orientation === orientation_default.top ? -1 : 1;
  var x;
  var y;
  var transform;
  if (orientation === orientation_default.top || orientation === orientation_default.bottom) {
    var yBottomOffset = orientation === orientation_default.bottom && typeof labelProps.fontSize === "number" ? labelProps.fontSize : 0;
    x = (Number(range[0]) + Number(range[range.length - 1])) / 2;
    y = sign * (tickLength + labelOffset + tickLabelFontSize + yBottomOffset);
  } else {
    x = sign * ((Number(range[0]) + Number(range[range.length - 1])) / 2);
    y = -(tickLength + labelOffset);
    transform = "rotate(" + sign * 90 + ")";
  }
  return {
    x,
    y,
    transform
  };
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/Ticks.js
var import_react3 = __toESM(require_react());
var import_classnames = __toESM(require_classnames());
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function Ticks(_ref) {
  var hideTicks = _ref.hideTicks, horizontal = _ref.horizontal, orientation = _ref.orientation, tickClassName = _ref.tickClassName, tickComponent = _ref.tickComponent, allTickLabelProps = _ref.tickLabelProps, _ref$tickStroke = _ref.tickStroke, tickStroke = _ref$tickStroke === void 0 ? "#222" : _ref$tickStroke, tickTransform = _ref.tickTransform, ticks = _ref.ticks, strokeWidth = _ref.strokeWidth, tickLineProps = _ref.tickLineProps;
  return ticks.map(function(_ref2) {
    var _allTickLabelProps$in;
    var value = _ref2.value, index = _ref2.index, from = _ref2.from, to = _ref2.to, formattedValue = _ref2.formattedValue;
    var tickLabelProps = (_allTickLabelProps$in = allTickLabelProps[index]) != null ? _allTickLabelProps$in : {};
    var tickLabelFontSize = Math.max(10, typeof tickLabelProps.fontSize === "number" && tickLabelProps.fontSize || 0);
    var tickYCoord = to.y + (horizontal && orientation !== orientation_default.top ? tickLabelFontSize : 0);
    return import_react3.default.createElement(Group, {
      key: "visx-tick-" + value + "-" + index,
      className: (0, import_classnames.default)("visx-axis-tick", tickClassName),
      transform: tickTransform
    }, !hideTicks && import_react3.default.createElement(Line, _extends2({
      from,
      to,
      stroke: tickStroke,
      strokeWidth,
      strokeLinecap: "square"
    }, tickLineProps)), tickComponent ? tickComponent(_extends2({}, tickLabelProps, {
      x: to.x,
      y: tickYCoord,
      formattedValue
    })) : import_react3.default.createElement(Text, _extends2({
      x: to.x,
      y: tickYCoord
    }, tickLabelProps), formattedValue));
  });
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisRenderer.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var defaultTextProps = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function AxisRenderer(_ref) {
  var axisFromPoint = _ref.axisFromPoint, axisLineClassName = _ref.axisLineClassName, axisToPoint = _ref.axisToPoint, hideAxisLine = _ref.hideAxisLine, hideTicks = _ref.hideTicks, horizontal = _ref.horizontal, _ref$label = _ref.label, label = _ref$label === void 0 ? "" : _ref$label, labelClassName = _ref.labelClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 14 : _ref$labelOffset, labelProps = _ref.labelProps, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? orientation_default.bottom : _ref$orientation, scale = _ref.scale, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? "#222" : _ref$stroke, strokeDasharray = _ref.strokeDasharray, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth, tickClassName = _ref.tickClassName, tickComponent = _ref.tickComponent, tickLineProps = _ref.tickLineProps, tickLabelProps = _ref.tickLabelProps, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, _ref$tickStroke = _ref.tickStroke, tickStroke = _ref$tickStroke === void 0 ? "#222" : _ref$tickStroke, tickTransform = _ref.tickTransform, ticks = _ref.ticks, _ref$ticksComponent = _ref.ticksComponent, ticksComponent = _ref$ticksComponent === void 0 ? Ticks : _ref$ticksComponent;
  var combinedLabelProps = _extends3({}, defaultTextProps, labelProps);
  var tickLabelPropsDefault = _extends3({}, defaultTextProps, typeof tickLabelProps === "object" ? tickLabelProps : null);
  var allTickLabelProps = ticks.map(function(_ref2) {
    var value = _ref2.value, index = _ref2.index;
    return typeof tickLabelProps === "function" ? tickLabelProps(value, index, ticks) : tickLabelPropsDefault;
  });
  var maxTickLabelFontSize = Math.max.apply(Math, [10].concat(allTickLabelProps.map(function(props) {
    return typeof props.fontSize === "number" ? props.fontSize : 0;
  })));
  return import_react4.default.createElement(import_react4.default.Fragment, null, ticksComponent({
    hideTicks,
    horizontal,
    orientation,
    scale,
    tickClassName,
    tickComponent,
    tickLabelProps: allTickLabelProps,
    tickStroke,
    tickTransform,
    ticks,
    strokeWidth,
    tickLineProps
  }), !hideAxisLine && import_react4.default.createElement(Line, {
    className: (0, import_classnames2.default)("visx-axis-line", axisLineClassName),
    from: axisFromPoint,
    to: axisToPoint,
    stroke,
    strokeWidth,
    strokeDasharray
  }), label && import_react4.default.createElement(Text, _extends3({
    className: (0, import_classnames2.default)("visx-axis-label", labelClassName)
  }, getLabelTransform({
    labelOffset,
    labelProps: combinedLabelProps,
    orientation,
    range: scale.range(),
    tickLabelFontSize: maxTickLabelFontSize,
    tickLength
  }), combinedLabelProps), label));
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/utils/getTickPosition.js
function getTickPosition(scale, align) {
  if (align === void 0) {
    align = "center";
  }
  var s = scale;
  if (align !== "start" && "bandwidth" in s) {
    var offset = s.bandwidth();
    if (align === "center") offset /= 2;
    if (s.round()) offset = Math.round(offset);
    return function(d) {
      var scaledValue = s(d);
      return typeof scaledValue === "number" ? scaledValue + offset : scaledValue;
    };
  }
  return scale;
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/utils/getTickFormatter.js
function getTickFormatter(scale) {
  var s = scale;
  if ("tickFormat" in s) {
    return s.tickFormat();
  }
  return toString;
}

// ../../node_modules/.pnpm/@visx+point@3.12.0/node_modules/@visx/point/esm/Point.js
var Point = function() {
  function Point2(_ref) {
    var _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y;
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point2.prototype;
  _proto.value = function value() {
    return {
      x: this.x,
      y: this.y
    };
  };
  _proto.toArray = function toArray() {
    return [this.x, this.y];
  };
  return Point2;
}();

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/utils/createPoint.js
function createPoint(_ref, horizontal) {
  var x = _ref.x, y = _ref.y;
  return new Point(horizontal ? {
    x,
    y
  } : {
    x: y,
    y: x
  });
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/utils/getAxisRangePaddingConfig.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var defaultAxisRangePadding = 0;
function getAxisRangePaddingConfig(originalRangePadding) {
  if (originalRangePadding === void 0) {
    originalRangePadding = defaultAxisRangePadding;
  }
  return typeof originalRangePadding === "number" ? {
    start: originalRangePadding,
    end: originalRangePadding
  } : _extends4({
    start: defaultAxisRangePadding,
    end: defaultAxisRangePadding
  }, originalRangePadding);
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/Axis.js
var _excluded3 = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function Axis(_ref) {
  var _ref$children = _ref.children, children = _ref$children === void 0 ? AxisRenderer : _ref$children, axisClassName = _ref.axisClassName, _ref$hideAxisLine = _ref.hideAxisLine, hideAxisLine = _ref$hideAxisLine === void 0 ? false : _ref$hideAxisLine, _ref$hideTicks = _ref.hideTicks, hideTicks = _ref$hideTicks === void 0 ? false : _ref$hideTicks, _ref$hideZero = _ref.hideZero, hideZero = _ref$hideZero === void 0 ? false : _ref$hideZero, innerRef = _ref.innerRef, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$numTicks = _ref.numTicks, numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? orientation_default.bottom : _ref$orientation, _ref$rangePadding = _ref.rangePadding, rangePadding = _ref$rangePadding === void 0 ? 0 : _ref$rangePadding, scale = _ref.scale, tickFormat = _ref.tickFormat, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickValues = _ref.tickValues, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, restProps = _objectWithoutPropertiesLoose3(_ref, _excluded3);
  var format = tickFormat != null ? tickFormat : getTickFormatter(scale);
  var isLeft = orientation === orientation_default.left;
  var isTop = orientation === orientation_default.top;
  var horizontal = isTop || orientation === orientation_default.bottom;
  var tickPosition = getTickPosition(scale);
  var tickSign = isLeft || isTop ? -1 : 1;
  var range = scale.range();
  var rangePaddingConfig = getAxisRangePaddingConfig(rangePadding);
  var axisFromPoint = createPoint({
    x: Number(range[0]) + 0.5 - rangePaddingConfig.start,
    y: 0
  }, horizontal);
  var axisToPoint = createPoint({
    x: Number(range[range.length - 1]) + 0.5 + rangePaddingConfig.end,
    y: 0
  }, horizontal);
  var filteredTickValues = (tickValues != null ? tickValues : getTicks(scale, numTicks)).filter(function(value) {
    return !hideZero || value !== 0 && value !== "0";
  }).map(function(value, index) {
    return {
      value,
      index
    };
  });
  var ticks = filteredTickValues.map(function(_ref2) {
    var value = _ref2.value, index = _ref2.index;
    var scaledValue = coerceNumber(tickPosition(value));
    return {
      value,
      index,
      from: createPoint({
        x: scaledValue,
        y: 0
      }, horizontal),
      to: createPoint({
        x: scaledValue,
        y: tickLength * tickSign
      }, horizontal),
      formattedValue: format(value, index, filteredTickValues)
    };
  });
  return import_react5.default.createElement(Group, {
    className: (0, import_classnames3.default)("visx-axis", axisClassName),
    innerRef,
    top,
    left
  }, children(_extends5({}, restProps, {
    axisFromPoint,
    axisToPoint,
    hideAxisLine,
    hideTicks,
    hideZero,
    horizontal,
    numTicks,
    orientation,
    rangePadding,
    scale,
    tickFormat: format,
    tickLength,
    tickPosition,
    tickSign,
    ticks
  })));
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisLeft.js
var import_react6 = __toESM(require_react());
var import_classnames4 = __toESM(require_classnames());
var _excluded4 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function _extends6() {
  _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var leftTickLabelProps = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function AxisLeft(_ref) {
  var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 36 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose4(_ref, _excluded4);
  var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends6({}, leftTickLabelProps, tickLabelProps);
  return import_react6.default.createElement(Axis, _extends6({
    axisClassName: (0, import_classnames4.default)("visx-axis-left", axisClassName),
    labelOffset,
    orientation: orientation_default.left,
    tickLabelProps: tickLabelPropsFinal,
    tickLength
  }, restProps));
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisRight.js
var import_react7 = __toESM(require_react());
var import_classnames5 = __toESM(require_classnames());
var _excluded5 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function _extends7() {
  _extends7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
function _objectWithoutPropertiesLoose5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var rightTickLabelProps = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function AxisRight(_ref) {
  var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 36 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose5(_ref, _excluded5);
  var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends7({}, rightTickLabelProps, tickLabelProps);
  return import_react7.default.createElement(Axis, _extends7({
    axisClassName: (0, import_classnames5.default)("visx-axis-right", axisClassName),
    labelOffset,
    orientation: orientation_default.right,
    tickLabelProps: tickLabelPropsFinal,
    tickLength
  }, restProps));
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisTop.js
var import_react8 = __toESM(require_react());
var import_classnames6 = __toESM(require_classnames());
var _excluded6 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function _extends8() {
  _extends8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
function _objectWithoutPropertiesLoose6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var topTickLabelProps = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function AxisTop(_ref) {
  var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 8 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose6(_ref, _excluded6);
  var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends8({}, topTickLabelProps, tickLabelProps);
  return import_react8.default.createElement(Axis, _extends8({
    axisClassName: (0, import_classnames6.default)("visx-axis-top", axisClassName),
    labelOffset,
    orientation: orientation_default.top,
    tickLabelProps: tickLabelPropsFinal,
    tickLength
  }, restProps));
}

// ../../node_modules/.pnpm/@visx+axis@3.12.0_react@18.3.1/node_modules/@visx/axis/esm/axis/AxisBottom.js
var import_react9 = __toESM(require_react());
var import_classnames7 = __toESM(require_classnames());
var _excluded7 = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function _extends9() {
  _extends9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
function _objectWithoutPropertiesLoose7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var bottomTickLabelProps = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function AxisBottom(_ref) {
  var axisClassName = _ref.axisClassName, _ref$labelOffset = _ref.labelOffset, labelOffset = _ref$labelOffset === void 0 ? 8 : _ref$labelOffset, _ref$tickLength = _ref.tickLength, tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength, tickLabelProps = _ref.tickLabelProps, restProps = _objectWithoutPropertiesLoose7(_ref, _excluded7);
  var tickLabelPropsFinal = typeof tickLabelProps === "function" ? tickLabelProps : _extends9({}, bottomTickLabelProps, tickLabelProps);
  return import_react9.default.createElement(Axis, _extends9({
    axisClassName: (0, import_classnames7.default)("visx-axis-bottom", axisClassName),
    labelOffset,
    orientation: orientation_default.bottom,
    tickLabelProps: tickLabelPropsFinal,
    tickLength
  }, restProps));
}
export {
  Axis,
  AxisBottom,
  AxisLeft,
  AxisRight,
  AxisTop,
  orientation_default as Orientation
};
//# sourceMappingURL=@visx_axis.js.map
